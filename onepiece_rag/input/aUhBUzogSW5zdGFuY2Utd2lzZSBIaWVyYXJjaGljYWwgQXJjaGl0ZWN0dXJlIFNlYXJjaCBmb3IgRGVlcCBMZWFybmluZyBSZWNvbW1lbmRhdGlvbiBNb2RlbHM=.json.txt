<h1>abstract</h1> <p>Current recommender systems employ large-sized embedding tables with uniform dimensions for all features, leading to overfitting, high computational cost, and suboptimal generalizing performance. Many techniques aim to solve this issue by feature selection or embedding dimension search. However, these techniques typically select a fixed subset of features or embedding dimensions for all instances and feed all instances into one recommender model without considering heterogeneity between items or users. This paper proposes a novel instance-wise Hierarchical Architecture Search framework, iHAS, which automates neural architecture search at the instance level. Specifically, iHAS incorporates three stages: searching, clustering, and retraining. The searching stage identifies optimal instance-wise embedding dimensions across different field features via carefully designed Bernoulli gates with stochastic selection and regularizers. After obtaining these dimensions, the clustering stage divides samples into distinct groups via a deterministic selection approach of Bernoulli gates. The retraining stage then constructs different recommender models, each one designed with optimal dimensions for the corresponding group. We conduct extensive experiments to evaluate the proposed iHAS on two public benchmark datasets from a real-world recommender system. The experimental results demonstrate the effectiveness of iHAS and its outstanding transferability to widely-used deep recommendation models. </p><h1>sections</h1><h2>heading</h2> <p>INTRODUCTION </p><h2>text</h2> <p>Recommender systems, which aim to predict the preference of users, have been widely deployed in various real-world scenarios, e.g., online advertising [3,27], social media [9], news apps [39], etc. Deep learning recommendation models (DLRMs) typically take a large amount of categorical (e.g., gender) or numerical (e.g., age) field features as input. These features are first encoded into highdimensional sparse one-hot vectors, which are later mapped into real-valued dense vectors via embedding tables. The recommender model then feeds these embeddings into a feature interaction layer which usually consists of deep neural network (DNN) [6] or factorization machine (FM) [8,14,26,34] to model user preferences for final prediction.
The embedding tables play a fundamental role in the recommendation system, as they dominate the majority of parameters. However, most existing methods construct their proposed recommender models with large-sized embedding tables and a uniform dimension size for all possible fields [8,10,29], which may lead to overfitting, high computational cost, and poor model generalization [15,25,33]. Therefore, the first objective for an optimal DLRM is to find optimal embedding dimensions for different fields and remove redundant dimensions. Performing embedding dimension search is also sufficient to include feature selection, i.e., the optimal dimension for a field feature could be zero, which means completely excluding this feature.
A common approach for embedding dimension search is to employ the l 0 norm on the dimensions to penalize the count of nonzero dimension entries. However, as the l 0 norm poses a computational challenge for gradient descent, researchers have attempted to substitute l 0 with a surrogate function, such as the l 1 norm for LASSO [32], yet achieving limited selection ability [35]. Recently, probabilistic approaches [18,33] suggest utilizing Bernoulli random variables (RVs) with Gumbel-Softmax approximations to identify the top ğ¾ features with the highest probabilities. Though these methods can be applied for dimension selection, we have empirically observed that the probabilities learned are often indistinguishable. Therefore, selecting the top ğ¾ features/dimensions based on these probabilities may inadvertently result in either the exclusion of critical features/dimensions or the inclusion of irrelevant ones.
Furthermore, prior approaches uniformly apply embedding dimension selection across all instances in the datasets, therefore disregarding the inherent variations between individual samples. This one-size-for-all approach can be inadequate in many scenarios, especially when dealing with highly heterogeneous populations where relevant features can significantly diverge across users or across items. For example, in a movie recommendation system, the feature "age" usually plays a crucial role in recommending Disney movies, thereby possibly necessitating a larger embedding dimension. Conversely, "age" is less relevant for comedy films, resulting in a smaller dimension size. Thus, it is evident that treating all instances identically may overlook these context-specific nuances. Intuitively speaking, when dimension selection is performed at the instance level, we can create neural architectures that are better suited to individual samples. Such an approach not only results in superior performance but also enables faster inference times by focusing on the most relevant dimensions of each sample.
In this paper, we propose an instance-wise Hierarchical Architecture Search framework, iHAS, which attempts to perform automatic architecture search on the instance level, using hierarchical training procedures for DLRMs. Specifically, iHAS includes three learning stages: searching, clustering, and retraining. The searching stage aims to find the optimal instance-wise embedding dimensions across different fields via a carefully designed "Bernoulli gate" with stochastic selection mode and a regularizer. After selecting instancewise embedding dimensions, we separate samples into different groups based on a novel deterministic selection approach in the clustering stage. The retraining stage trains different recommender models, with optimal dimensions tailored to different groups. During inference time, each test sample will first be assigned to a suitable group, where predictions are made by the corresponding recommender model. We summarize our major contributions as:
â€¢ We propose a hierarchical training framework that uses instance-wise "Bernoulli gates" to facilitate effective dimension search for each sample. â€¢ We apply a sparse and bi-polarization regularizer in the objective function to help the model learn distinguishable Bernoulli RVs, and use a threshold selector for downstream deterministic selection. â€¢ To balance the trade-off between the one-size-for-all and full-customization (which is not applicable with finite data size) strategies, we propose to divide samples into clusters and develop tailored recommender models for each cluster.
We empirically evaluate the performance of our framework on two large-scale benchmark datasets. Our experimental results indicate a notable superiority of our approach over various state-of-the-art baseline models on both datasets. Furthermore, the transferability analysis demonstrates our framework can be effectively transferred to diverse deep recommender models, thereby enhancing their performance. Additionally, our framework offers an efficiency advantage as it requires less inference time than competing baseline models. </p><h2>publication_ref</h2> <p>['b2', 'b26', 'b8', 'b38', 'b5', 'b7', 'b13', 'b25', 'b33', 'b7', 'b9', 'b28', 'b14', 'b24', 'b32', 'b31', 'b34', 'b17', 'b32'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>RELATED WORK </p><h2>text</h2> <p>This section introduces the main related works to our study, focusing on feature-based recommender models and AutoML approaches for recommendation systems. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Feature-based Recommender Models </p><h2>text</h2> <p>Feature-based recommender models take sparse, high-dimensional features from users and items as input and transform them into low-dimensional representations to capture user preferences for improved recommendations. For example, Cheng et al. [4] propose Wide&Deep (W&D), a model composed of a linear module and a Multi-Layer Perceptron (MLP) layer to combine the benefits of memorization and generalization for recommender systems. Guo et al. [8] propose DeepFM that further integrates the power of factorization machines based on W&D to learn high-order feature interactions for recommendations. Recently, advanced neural networks, such as attention-based models [29], have been developed. However, these techniques apply a fixed embedding dimension for all features, which would downgrade the model performance and consume substantial computational resources. </p><h2>publication_ref</h2> <p>['b3', 'b7', 'b28'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>AutoML for Recommendations </p><h2>text</h2> <p>Automated Machine Learning (AutoML) has recently become a research hotspot due to its potential to automate the design process for recommender systems, minimizing human involvement. The research directions include feature selection [15,33], embedding dimension search [37,38], model architecture search [5], and other component search [30,31,36]. Feature selection involves selecting a subset of field features in recommendation systems. For example, AutoField [33] uses a simple controller based on differentiable architecture search [16] to select the top ğ¾ field features. AdaFS [15] enhances AutoField by modifying the controller to assign feature weights to fields for different samples. The objective of embedding dimension search is to find mixed embedding sizes for each field. For example, AutoEmb [38] finds the optimal dimension for each feature using differentiable search [16]. AutoDim [37] selects the best dimension for each field from a group of candidate dimensions in the same way as AutoEmb. Model architecture search explores various network architectures and selects the optimal one [5].
Our method is in alignment with embedding dimension search. All instances in the above methods share a uniform dimension size for each field. In contrast, our approach adaptively selects dimensions for each instance via the proposed Bernoulli gates, thereby considering the difference between individuals. Moreover, we introduce a polarization regularizer to overcome the shortcomings of the commonly-used top ğ¾ selection strategy. Furthermore, rather than processing all samples through a single model, we propose to divide samples into clusters and train different recommender models with optimal dimensions tailored to different clusters. These unique and innovative designs in our proposed method have been proven effective in terms of both performance enhancement and inference cost saving. </p><h2>publication_ref</h2> <p>['b14', 'b32', 'b36', 'b37', 'b4', 'b29', 'b30', 'b35', 'b32', 'b15', 'b14', 'b37', 'b15', 'b36', 'b4'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>METHOD </p><h2>text</h2> <p>This section introduces the technical specifications of the proposed iHAS framework, as visualized in Figure 1. We first provide a concise overview of the entire hierarchical training framework. Subsequently, the primary modules within our framework are described, as well as how to optimize them within each hierarchical stage. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>['fig_0'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Overview </p><h2>text</h2> <p>The methodology for the iHAS framework comprises three stages: searching, clustering, and retraining. It involves three principal modules: deep recommendation models (consisting of an embedding layer and an MLP component) for predicting user preferences, a Bernoulli gates layer responsible for dimension selection, and a K-means cluster algorithm that partitions the heterogeneous data.
In the searching stage, the key objective is to identify the optimal, instance-wise embedding dimensions across different fields, thus facilitating an accurate recommendation prediction. As shown in Figure 1, the categorical field features are directed to an embedding layer to generate embedding representations. These representations are then processed through the Bernoulli gates to produce embedding masks using a stochastic selection mode (see Section 3.3.1). Each embedding mask comprises a binary vector that serves as a gate on whether the corresponding dimension should be incorporated into the downstream architecture. Then the framework conducts an element-wise multiplication between a sample's embedding representations and embedding masks. This resultant masked embedding representation is then directed to the base MLP component to predict user preference.
In the clustering stage, the main objective is to utilize K-Means algorithm [28] to cluster samples into groups. This stage mostly mirrors the procedure used in the searching stage: using the embedding layer and Bernoulli gates (but using deterministic selection mode, see Section 3.3.2) to calculate the masked embedding representations. These masked embedding representations are then used to train a mini-batch K-Means cluster [28]. As shown in Figure 1, the K-means separates the red and yellow samples from the blue and green samples.
The retraining stage aims to develop cluster-customized DLRMs, considering the variation in dimension patterns across different clusters. In each cluster, we calculate the embedding masks (using deterministic selection mode) for all samples. The resultant masks are then averaged to obtain one vector, which is used to determine the final embedding dimensions of each DLRM. </p><h2>publication_ref</h2> <p>['b27', 'b27'] </p><h2>figure_ref</h2> <p>['fig_0', 'fig_0'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Deep Learning Recommender Models </p><h2>text</h2> <p>In this subsection, we provide a brief introduction to the basic architecture of the DLRM. It typically comprises two primary components: an embedding layer and an MLP component. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Embedding Layer. </p><h2>text</h2> <p>In classic DLRM, the embedding layer is commonly used to convert the categorical inputs into a dense vector of real numbers.
Let us denote the input of ğ‘ categorical field features for sample
ğ‘– as ğ‘¿ ğ‘– = [ğ’™ ğ‘–,1 , â€¢ â€¢ â€¢ , ğ’™ ğ‘–,ğ‘› , â€¢ â€¢ â€¢ , ğ’™ ğ‘–,ğ‘ ],
where ğ’™ ğ‘–,ğ‘› âˆˆ Z |ğ‘› | represents the one-hot vector comprising sparse, high-dimensional binary values. The term |ğ‘›| denotes the number of unique values for ğ‘›-th categorical field. For instance, a categorical field such as "gender" with unique valuesmale, female, and unknown -can be expressed through three-bit vectors [1, 0, 0], [0, 1, 0], and [0, 0, 1], respectively.
To process a numerical field feature, we will discretize it through custom-width binning, followed by applying a one-hot operation.
Then, the operation of the embedding layer can be represented as:
ğ’† ğ‘–,ğ‘› = ğ’— ğ‘› ğ’™ ğ‘–,ğ‘› ,
where
ğ’— ğ‘› âˆˆ R ğ‘‘ Ã— |ğ‘› |
is the embedding table of the ğ‘›-th field, ğ‘‘ is the predefined embedding dimension (typically consistent across all fields), and ğ’† ğ‘–,ğ‘› is the low-dimensional embedding representation. Therefore, the final embedding of the input data ğ‘¿ ğ‘– through ğ‘ embedding tables is
ğ‘¬ ğ‘– = [ğ’† ğ‘–,1 , â€¢ â€¢ â€¢ , ğ’† ğ‘–,ğ‘› , â€¢ â€¢ â€¢ , ğ’† ğ‘–,ğ‘ ].
Notably, the embedding dimension search techniques we discussed earlier in Section 2.2 (also the focus of this paper) aim at searching the optimal dimensions for embedding tables
ğ‘½ = [ğ’— 1 , â€¢ â€¢ â€¢ , ğ’— ğ‘› , â€¢ â€¢ â€¢ , ğ’— ğ‘ ].
Specifically, our goal is to discover the optimal individual embedding dimension for each field, given the inherent diversity in the heterogeneous dataset. This could potentially enhance prediction performance. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>MLP Component. </p><h2>text</h2> <p>The MLP component plays a crucial role in DLRMs, tasked with encoding embedding representations and predicting the recommendation. Empirically, it comprises multiple fully-connected (FC) layers (characterized by parameter ğœ½ ) and is also equipped with non-linear activation functions such as ReLU [1] or Sigmoid, thereby facilitating the nonlinear encoding process of these representations.
In the iHAS system, we will train three different DLRMs, as illustrated in Figure 1. Each DLRM consists of an embedding layer and an MLP component. These three models are named the base recommender model, recommender model 1, and recommender model 2, which are characterized by the parameter groups ğ‘½, ğœ½  ğ‘ , ğ‘½, ğœ½  1 , and ğ‘½, ğœ½  2 , respectively. </p><h2>publication_ref</h2> <p>['b0'] </p><h2>figure_ref</h2> <p>['fig_0'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Bernoulli Gates </p><h2>text</h2> <p>Bernoulli gates operate as switches, facilitating the transmission of a sample's information from embedding tables to the downstream MLP component. Analogous to the l 0 norm, we hope these "switches" to be capable of fully opening or closing without compromising the information integrity (shrinking the embedding representation). Inspired by the approach presented in [18,35], we use Bernoulli gates to predict each sample's relevant dimensions given its embedding representation. The detailed process of the Bernoulli gates is graphically depicted in Figure 2.
The Bernoulli gates operate in two distinct modes: stochastic selection and deterministic selection. Under the stochastic selection mode, the gates operate as independent Bernoulli distributions, to independently "open" or "close" dimensions given the probabilities. The principle behind stochastic selection rests on the assumption that, given a sufficiently large number of training iterations, the gates will stochastically and comprehensively traverse all potential combinations of dimensions. This prompts the Bernoulli parameters to increase for beneficial dimensions and penalize unhelpful ones. Once the Bernoulli distributions (gates) have been fully explored, we capitalize on the learned distribution by deterministically opening the most advantageous dimensions in the deterministic selection mode. However, learned Bernoulli probabilities often exhibit heavy-tailedness, making it challenging to distinguish between important and unimportant dimensions. To mitigate this, we suggest employing a polarization regularizer and an automatic threshold searcher (both discussed in Section 3.3.3) inside Bernoulli gates. </p><h2>publication_ref</h2> <p>['b17', 'b34'] </p><h2>figure_ref</h2> <p>['fig_1'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Stochastic Selection. </p><h2>text</h2> <p>In our previous discussion, we aim for Bernoulli gates to function as independent Bernoulli distributions in the stochastic selection mode during the searching stage. The first objective is to encode the embedding representations to the desired independent Bernoulli probabilities. To this end, we employ an FC layer (with parameter ğ’˜) and a Sigmoid activation layer (ğœ) to project these embedding representations of the ğ‘–-th sample onto Bernoulli probabilities (upper left of Figure 2), denoted by ğ‘ ğ‘–,ğ‘—  ğ‘ * ğ‘—=1 = ğœ (ğ’˜ ğ‘¬ ğ‘– ), where ğ‘ * = ğ‘ Ã— ğ‘‘ is the total length of the embedding representations. This enables us to initiate a combinatorial search process over the space of Bernoulli probabilities and FC parameters. However, optimizing a loss function, which includes discrete RVs (Bernoulli distributions), incurs high variance [23]. To overcome this obstacle, we adopt Gumbel-Softmax [11] (aka Concrete distribution [21]), which offers a viable continuous approximation to the Bernoulli distribution, as visualized in Figure 2 (right).
Recall that Gumbel-Max [7,22] is an effective method for drawing samples from a Bernoulli distribution (or any type of discrete random variables), as long as we provide the class probabilities. For instance, if we use ğ‘ ğ‘–,ğ‘— and 1 -ğ‘ ğ‘–,ğ‘— as the probabilities for selecting and not selecting the ğ‘—-th embedding dimension for sample ğ‘–, respectively, the Gumbel-Max trick to approximate Bernoulli distribution sampling can then be expressed as:
ğ’› ğ‘–,ğ‘— = one hot (arg max (log ğ‘ ğ‘–,ğ‘— + ğº ğ‘–,ğ‘— , log(1 -ğ‘ ğ‘–,ğ‘— ) + ğº â€² ğ‘–,ğ‘— )),(1)
where ğº ğ‘–,ğ‘— and ğº â€² ğ‘–,ğ‘— are i.i.d. samples drawn from a Gumbel distribution with the location at 0 and scale of 1, denoted as Gumbel(0, 1). However, both the "one hot()" and "arg max()" operations are nondifferentiable, making them intractable for gradient descent optimization. Therefore, the softmax function is used as a continuous, (2) As ğœ approaches 0, ğ’› ğ‘–,ğ‘— approximates the true binary vector, making the Gumbel-Softmax distribution become identical to the desired Bernoulli distribution. Then the final embedding masks, ğ’ ğ‘– , are created by concatenating the first bit of ğ’› ğ‘–,ğ‘—  ğ‘ * ğ‘—=1 . However, our goal remains to produce true binary masks, which would effectively eliminate information from unimportant dimensions, as opposed to significantly shrinking them. The straightthrough (ST) Gumbel-Softmax [2,11] serves well in this context. In the ST variant, the operation from Equation 1 is implemented in the forward pass while the continuous approximation from Equation 2is used in the backward gradient descent. This approach enables sparse selection even when the temperature ğœ is high, while still allowing the gradient to propagate and update the parameters. </p><h2>publication_ref</h2> <p>['b22', 'b10', 'b20', 'b6', 'b21', 'b1', 'b10'] </p><h2>figure_ref</h2> <p>['fig_1', 'fig_1'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Deterministic Selection. </p><h2>text</h2> <p>After training the Bernoulli probabilities (ğ‘ ğ‘–,ğ‘— ) during the searching phase, we utilize these probabilities to determine which dimensions will contribute to the accuracy of the recommendation predictions. However, ğ‘ ğ‘–,ğ‘— are characterized by high variance and heavy-tailedness, as shown by the histogram in Figure 3 (left). These present two complications: (1) distinguishing important dimensions from unimportant ones becomes challenging; and (2) even the unimportant dimensions still possess a small probability of being selected. Moreover, masks created using Bernoulli gates introduce an element of randomness (Gumbel noise), which hinders their direct application during inference (where given the same data each time, consistent results should be generated).
To overcome these limitations, we propose a deterministic selection mode that directly selects the beneficial dimensions using the knowledge derived from the well-trained Bernoulli probabilities. This process is outlined in Figure 2 (bottom left). Firstly, we use the same FC layer and sigmoid layer to estimate the Bernoulli probabilities, ğ‘ ğ‘–,ğ‘— , analogous to the first step in the stochastic selection mode.
Then, for each sample ğ‘–, we search a threshold among the probabilities ğ‘ ğ‘–,ğ‘—  ğ‘ * ğ‘—=1 (see details in Section 3.3.3). We automatically adjust the gates to be open for probabilities exceeding this threshold and closed for those falling below it. The resulting embedding masks are utilized during the clustering and retraining phase (see Figure 1). </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>['fig_2', 'fig_1', 'fig_0'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Polarization and Automatic Threshold </p><h2>text</h2> <p>Searcher. Let's consider an empirical optimization procedure with an l 0 regularization on the embedding masks during the searching stage:
R ( ğ‘½, ğœ½  ğ‘ , ğ’ ) = E ğ‘– E ğ’ ğ‘– L( ğ‘“ ğœ½ ğ‘ ( ğ‘½ ğ‘ â€¢ ğ‘¿ ğ‘– âŠ™ ğ’ ğ‘– ), ğ‘¦ ğ‘– ) , (3) with regularizer R (ğ’) = E ğ‘– E ğ’ ğ‘– [ ğœ† âˆ¥ğ’ ğ‘– âˆ¥ 0 ] ,(4)
where L( ğ‘—=1 ğ‘ ğ‘–,ğ‘— . Our experimentation, however, indicates that simply using this l 0 regularizer still experiences the heavy-tailedness and distinction difficulties, as discussed in Section 3.3.2. Inspired from Zhuang et al. [41], we incorporate a polarization regularizer into Equation 4:
R (ğ’) = âˆ‘ï¸ ğ‘– ğ‘ * âˆ‘ï¸ ğ‘—=1 ğœ† ğ‘ ğ‘–,ğ‘— -|ğ‘ ğ‘–,ğ‘— -pğ‘– |, with pğ‘– = 1 ğ‘ * ğ‘ * âˆ‘ï¸ ğ‘—=1 ğ‘ ğ‘–,ğ‘— .(5)
The intuition of the second term (which is the polarization regularizer) is to maximally distance ğ‘ ğ‘–,ğ‘— from their mean pğ‘– . Empirically, we have observed this polarization term effectively separates the probabilities of important and unimportant dimensions into two groups, thereby making them distinguishable (see Figure 3). Despite employing the regularizer as stated in Equation 5, a threshold searcher is still required to identify the threshold for ğ‘ ğ‘–,ğ‘— . Currently, the histogram of ğ‘ ğ‘–,ğ‘— trained with the polarization regularizer should have at least two peaks, with one of them located close to 0. Following the strategy from [41], we scan the histogram from left to right to identify the first saddle point, i.e., the bin that contains the local minimum (the red pin in Figure 2). The lower bound of this bin is subsequently set as the threshold. </p><h2>publication_ref</h2> <p>['b40', 'b40'] </p><h2>figure_ref</h2> <p>['fig_2', 'fig_1'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Clusters </p><h2>text</h2> <p>Once obtaining a sample's unique embedding masks, our aim is to pass this sample through a recommender model tailored to its distinct dimension selection. This implies that, for every sample with its individual selected dimensions, there always exists a customized recommender model capable of handling this distinct input and generating a precise prediction. Nonetheless, training an extensive number of recommender models is impractical due to the constraint of finite data size. For example, with a obviously underestimated dimension, ğ‘ * = 100, the number of possible combinations of dimensions is 100 ğ‘˜=0 100 ğ‘˜ = 2 100 , meaning at least 2 100 distinct samples should be collected.
Consequently, we must strike a balance between using a one-sizefits-all recommender model (inadequate for highly heterogeneous samples) and using a fully-customized recommender model for each sample. Our resolution is to leverage clustering algorithms to segregate samples into separate groups. We anticipate that samples update ğ‘½, ğœ½  1 according the objective from Eq. 3 20: end while 21: repeat lines 16-20 with D train 2 , D val 2 , and ğ‘½, ğœ½  2 within the same group display similar patterns, which could be used to explore identical dimension patterns and identical recommender models. Furthermore, partitioning the data into clusters facilitates the training of small and manageable models for each cluster, thus accelerating the inference speed.
In this iHAS framework, we opt for the mini-batch K-Means clustering algorithm [28] to partition the samples. We chose this variant due to its computational efficiency in handling large datasets (comprised of tens of millions of samples), and its capacity to avoid getting stuck at local optima. </p><h2>publication_ref</h2> <p>['b27'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Optimization Strategy </p><h2>text</h2> <p>In the iHAS framework, we adopt a hierarchical training strategy to optimize different modules in different stages, inspired by [12,15,24,33], to tackle the encoding issue of jointly optimizing all modules. The detailed optimization strategy in each stage is illustrated in Algorithm 1. [35], the use of Gumbel-Softmax approximation for the discrete random variable suffers from high variance, which can lead to inconsistency in the set of selected dimensions. Inspired by [15], we first pretrain the base recommender model for a few epochs to obtain a tentative reliable embedding representation. During these pretrain epochs, the Bernoulli gates are always deterministically open (no matter what embedding representation it receives). Then, after we've obtained a tentative reliable embedding representation, we initialize the parameters for the Bernoulli gates and start the stochastic selection. Later we adopt the bi-level optimization strategy [12,24] to disjointly update the parameters ğ’˜ in Bernoulli gates and the parameters ğ‘½, ğœ½  b in the base recommender model. </p><h2>publication_ref</h2> <p>['b11', 'b14', 'b23', 'b32', 'b34', 'b14', 'b11', 'b23'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Searching Stage. As mentioned in </p><h2>text</h2> <p> </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Clustering Stage. </p><h2>text</h2> <p>In the clustering stage, we can obtain the masked embedding representations using the embedding tables and Bernoulli gates which have been trained during the searching stage. Remember we use deterministic selection mode for Bernoulli gates to generate embedding masks in this clustering stage. For each sample, compute its Euclidean distance to the centroid using the masked embedding representations, then assign it to the nearest centroid (group), and later update the centroids. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Retraining Stage. </p><h2>text</h2> <p>As to the retraining stage, we first divide all samples via the trained K-Means cluster. Then we find the majority dimensions for each group from their embedding masks using the deterministic mode. After that, we initialize the deep recommender model 1 and 2 by their corresponding optimal dimensions and train them separately using the samples of each cluster. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>EXPERIMENT </p><h2>text</h2> <p>In this section, we conduct extensive experiments to evaluate our proposed framework. Specifically, the main research questions we care about are as follows:
â€¢ RQ1: How does iHAS perform compared with other mainstream selection methods? â€¢ RQ2: Can the proposed iHAS be successfully transferred to more powerful recommender models? â€¢ RQ3: How does each component contribute to the overall performance of the proposed iHAS? â€¢ RQ4: Does the proposed iHAS demonstrate efficiency when compared to baseline models? â€¢ RQ5: Does iHAS construct rational recommender model structures? </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Datasets </p><h2>text</h2> <p>We conduct our experiments mainly on two commonly used public datasets, Avazu 1 and Criteo 2 , which are both large-scale realworld datasets and serve as benchmarks in click-through rate (CTR) prediction tasks. Table 1 presents the detailed statistics of both datasets. Each dataset has been randomly segmented into training/validation/testing sets based on the proportions of 80%, 10%, and 10%.
â€¢ Avazu dataset consists of 40 million users' click records on ads over 11 days. Each record contains 22 categorical field features. Following the general preprocessing steps [29,40],
1 https://www.kaggle.com/c/avazu-ctr-prediction/ 2 https://www.kaggle.com/c/criteo-display-ad-challenge/ we group fields of which frequency is less than ten as a single field "others". â€¢ Criteo dataset consists of 46 million users' click records on display ads. Each record contains 26 categorical fields and 13 numerical fields. we use the preprocessing method as Avazu for the low-frequency fields (less than ten) and transform each numerical field ğ‘¥ by ğ‘™ğ‘œğ‘” 2 (ğ‘¥) if ğ‘¥ > 2. </p><h2>publication_ref</h2> <p>['b28', 'b39'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_1'] </p><h2>heading</h2> <p>Evaluation Metrics </p><h2>text</h2> <p>Following the previous works [17,25], we evaluate the performance of our method using two common metrics: AUC and Logloss. AUC refers to the area under the ROC curve, which means the probability that a model will rank a randomly selected positive instance higher than a randomly selected negative one. A higher AUC value indicates superior model performance. On the other hand, Logloss, aka binary cross-entropy loss, directly quantifies the model's performance, with a lower score denoting more accurate predictions. Note that a marginal 0.001-level improvement in AUC (increase) or Logloss (decrease) is perceived as a significant enhancement in model performance [19,33,37]. </p><h2>publication_ref</h2> <p>['b16', 'b24', 'b18', 'b32', 'b36'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Baseline Methods </p><h2>text</h2> <p>We compare our proposed method with the following state-of-theart methods:
â€¢ PEP [17]: It adopts trainable thresholds to prune redundant embedding dimensions. â€¢ AutoField [33]: It utilizes neural architecture search techniques [16] to select important field features. â€¢ OptEmbed [20]: It trains a supernet with various selected embedding dimensions, then uses evolution search to find the optimal embedding dimensions based on the supernet. â€¢ AdaFS [15]: It assigns weights to different fields in a soft manner (AdaFS-soft) or masks unimportant fields in a hard manner (AdaFS-hard) via a novel controller network. â€¢ OptFS [19]: It simultaneously selects optimal field features and the optimal interactions between these features using "binary gates". </p><h2>publication_ref</h2> <p>['b16', 'b32', 'b15', 'b19', 'b14', 'b18'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Implementation Details </p><h2>text</h2> <p>We implement our method based on a public libraryfoot_0 that involves sixteen commonly-used DLRMs. As our framework is modelagnostic, it can be seamlessly integrated with any of these models, see Section 4.6. For the embedding layer, we set the initial embedding size of all fields as 16 in accordance with the previous works [15,33]. For the MLP component, we adopt two fully-connected layers of size (16,8) with the ReLU activation function. We use Adam optimizer [13] with an initial learning rate of 0.001, and weight decay of 1e-6. The batch size is set to 2048. We sample one validation batch every 100 training batches for bi-level optimization.
The temperature ğœ for ST Gumbel-Softmax is set to 0.1. The baseline models are implemented by the codes provided by their authors. For a fair comparison, we set the initial embedding dimension as 16 for all baselines. All the experiments are run on a single machine with an Nvidia RTX 3090 GPU.  First, our iHAS outperforms all the state-of-the-art baseline methods as it can achieve higher AUC and lower Logloss on both datasets, demonstrating the effectiveness of iHAS in deep recommendation systems. Specifically, iHAS outperforms the runner-ups by 0.0038 (AUC) and 0.0021 (Logloss) on the Avazu datasets, and by 0.0004 (AUC) and 0.0006 (Logloss) on the Criteo datasets.
Secondly, among all baselines, AdaFS-soft is the most effective model for the Avazu and Criteo datasets. However, it only shrinks the field features using a feature weighting layer and therefore does not completely eliminate the effect of unimportant fields. Although AdaFS-hard attempts to mask unimportant fields by uniformly keeping the top ğ¾ features, the trained feature weights may still exhibit a high variance pattern (remember the non-distinguishable probabilities in Figure 3, left panel). Therefore, this top ğ¾ selection manner may lead to selecting unimportant features or omitting the important feature in their final model, further compromising the model performance. Our polarization regularizer and threshold searcher can help with this issue, as detailed in Section 3.3.3 and evidenced by the empirical ablation study in Section 4.7.
Lastly, other baselines apply global feature/dimension selection across all samples, which fails to account for inherent variations among heterogeneous individuals, and consequently leads to suboptimal performance. Additionally, PEP mainly emphasizes on the model size, i.e., it stops searching once the embedding table reaches a predefined parameter size. This approach may result in a suboptimal embedding table due to overlooking the model performance. AutoFieldfoot_1 also employs the top ğ¾ selection manner, again leading to feature misselection and inferior model performance. </p><h2>publication_ref</h2> <p>['b14', 'b32', 'b15', 'b7', 'b12'] </p><h2>figure_ref</h2> <p>['fig_2'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Transferability Analysis (RQ2) </p><h2>text</h2> <p>In this subsection, we explore the transferability of iHAS. Specifically, we freeze the parameters of the well-trained Bernoulli gates and utilize them to help train other popular deep recommendation models, including FM [26], W&D [4], and DeepFM [8].
Table 3 shows the experimental results on Avazu, where "original" refers to the corresponding model without any selection. We can observe that: (i) all the recommendation models have great improvement by adopting iHAS, which again demonstrates the importance of performing selection in the recommendations; (ii) The transferability of iHAS is better than the best baseline (by comparing the iHAS and AdaFS-soft in Table 3), which validates the effectiveness of our Bernoulli gates.
In summary, we conclude that iHAS has outstanding transferability across different recommendation models, which enables it to be leveraged in complicated real-world recommender systems. </p><h2>publication_ref</h2> <p>['b25', 'b3', 'b7'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_4', 'tab_4'] </p><h2>heading</h2> <p>Ablation Study (RQ3) </p><h2>text</h2> <p>In this subsection, we conduct the ablation study of key components in iHAS, as shown in Table 4. The Base model keeps all fields and the uniform embedding dimensions without any selections, and we derive four variants from iHAS: (i) iHAS-1: This variant is the model directly obtained in the searching stage, i.e., we remove the clustering and retraining stages; (ii) iHAS-2: This variant consists of a searching stage and a retraining stage. After we have the welltrained Bernoulli gates, we select dimensions across all samples to retrain one recommender model instead of separating samples into different clusters for retraining cluster-customized recommender models; (iii) iHAS-3: This variant is the standard iHAS without using the polarization regularizer described in Section 3. initialized vector of the dimension length, making every sample share the same probability for every dimension.
Based on the results in Table 4, we can find: (i) iHAS and its variants can increase the AUC and decrease the Logloss compared with the Base model, which indicates the necessity of performing selection on embedding dimensions for boosting model performance; (ii) iHAS performs better than iHAS-1, which indicates the necessity of the subsequent clustering and retraining stages; (iii) iHAS-1 outperforms iHAS-2, therefore, separating instances into different groups, i.e., the clustering stage, is beneficial for boosting the performance; (iv) Polarization is vital for acquiring better Bernoulli gates by comparing iHAS with iHAS-3; (v) Respecting the difference between instances can further boost the performance by comparing iHAS with iHAS-4. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_5', 'tab_5'] </p><h2>heading</h2> <p>Efficiency Analysis (RQ4) </p><h2>text</h2> <p>In addition to model performance, efficiency is vital when deploying the recommendation model into online systems, especially inference efficiency. We report the inference time on the whole test set of iHAS and other baselines in Figure 4. We can find that iHAS achieves the least inference time. This is because iHAS feed different test data into its preferred recommender model of smaller size instead of feeding all test data into a single model which may lead to additional inference cost on some data. On the contrary, PEP requires the longest inference time because its embedding table is usually sparse and hardware-unfriendly. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>['fig_4'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Case Study (RQ5) </p><h2>text</h2> <p>In this subsection, we first use a case study to investigate the optimal embedding dimensions for each cluster from iHAS. We show the results on Avazu as an example and exclude all anonymous field features in Figure 5.
We can observe that: (i) Each field's optimal dimensions greatly vary from one to another (from 4 to 12), which highlights the necessity of dimension search in recommender systems; (ii) idrelated features, e.g., site_id and app_id, typically possess more dimensions. This aligns with human intuition as the id-related features are the core of recommender systems; (iii) Samples within different clusters tend to select different dimensions for each field, which validates our claim that different clusters present different  patterns and should be trained separately to enhance performance and reduce inference time in Section 3.4. Furthermore, we use four samples to illustrate the effectiveness of the iHAS framework consisting of group-customized recommender models. Figure 6 shows four samples grouped into two clusters (two in pink and two in cyan). Each cluster has its customized recommender model. We can find that the predictions are more correct (lower Logloss) if we feed the sample into its corresponding model. However, if feeding all of them together into one of the recommender models, we will receive some wrong predictions. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>CONCLUSION </p><h2>text</h2> <p>This study proposes an instance-wise Hierarchical Architecture Search framework, iHAS, as an innovative solution to the challenges associated with identifying optimal embedding dimensions for DLRMs. iHAS employs a three-stage hierarchical training strategy including searching, clustering, and retraining. The searching stage aims to identify the optimal embedding dimensions for each sample across different fields. Subsequent stages of clustering and retraining provide a mechanism for gathering similar samples as clusters and training cluster-customized DLRMs based on the individual optimal dimensions, thereby enhancing recommendation predictions. We conduct extensive experiments on two large-scale datasets to authenticate the efficacy of the proposed framework. The results demonstrate that iHAS could boost the performance of deep recommendations while reducing inference costs. Additionally, iHAS exhibits outstanding transferability to popular DLRMs. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p>